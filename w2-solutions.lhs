* Exercises I

 1. ∀ x. ⊥ -> P(x)

 2. ∀ x. P(x) , P(t) -> Q ⊢ Q

* Solutions I

 1.
 ⊥ ⊢ ⊥
 ========== ⊥E
 ⊥ ⊢ P(x)
 ============= ->I
 ⊢ ⊥ -> P(x)
 ================== ∀I
 ⊢ ∀ x. ⊥ -> P(x)

 2.
 Let Γ = ∀ x. P(x), P(t) -> Q.

                    ============= ax
                    Γ ⊢ ∀x. P(x)
 ============== ax  ============= ∀E
 Γ ⊢ P(t) -> Q      Γ ⊢ P(t)
 ============================= ->E
   ∀ x. P(x), P(t) -> Q ⊢ Q


* Exercises II
 3. (∀ x y. P(x,y)) -> (∀ b a. P(a,b))
 4. ∃ x. P(x) ⊢  ¬ ∀ x. ¬ P(x)
 5. (∃ x. P(x) ∧ Q(x)) -> ∃ x. P(x)
 [ 6. ∀x y z. P(x,y) ∧ P(y,z) -> P(x,z), P(a,b), P(b,c) ⊢ P(a,c) ]
 [ 7. ¬ ∀ x. ¬ P(x) ⊢ ∃ x. P(x) using TND]

* Solutions II

 3. Let  Γ := ∀ x. ∀ y. P(x,y).

 ======================= ax
  Γ ⊢ ∀ x y. P(x,y)
 ======================= ∀E
  Γ ⊢ ∀ y. P(a,y)
 ======================= ∀E
  Γ ⊢ P(a,b)
 ======================= ∀I
  Γ ⊢ ∀ a. P(a,b)
 ======================= ∀I
  Γ ⊢ ∀ b. ∀ a. P(a,b)
 =================================== -> I
  (∀ x y. P(x,y)) -> (∀ b a. P(a,b))


 4. Let Γ := ∃ x. P(x), ∀ x. ¬ P(x).

                          ===================== ax
                          Γ,P(t) ⊢ ∀ x. ¬ P(x)
                         ====================== ∀E  ============== ax
                          Γ,P(t) ⊢ ¬P(t)            Γ,P(t) ⊢ P(t)
 ================ ax     ======================================= ¬E
  Γ ⊢ ∃ x. P(x)          Γ,P(t) ⊢ ⊥
 ================================================ ∃E
  ∃ x. P(x), ∀ x. ¬ P(x) ⊢ ⊥
 ============================ ¬I
  ∃ x. P(x) ⊢  ¬ ∀ x. ¬ P(x)


 5. Let Γ1 := ∃ x. P(x) ∧ Q(x);  Γ2 := Γ1, P(x) ∧ Q(x)

                               ================== ax
                                Γ2 ⊢ P(x) ∧ Q(x)
                               ================== ∧EL
                                    Γ2 ⊢ P(x)
 ======================= ax    ================== ∃I
  Γ1 ⊢ ∃ x. P(x) ∧ Q(x)          Γ2 ⊢ ∃ x. P(x)
 ================================================ ∃E
            Γ1 ⊢ ∃ x. P(x)
 =================================== -> I
  ⊢ (∃ x. P(x) ∧ Q(x)) -> ∃ x. P(x)


 6. Let Γ := ∀ x y z. P(x,y) ∧ P(y,z) -> P(x,z), P(a,b), P(b,c)

 ========================================== ax
  Γ ⊢ ∀ x y z. (P(x,y) ∧ P(y,z)) -> P(x,z)
 ========================================== ∀E
  Γ ⊢ ∀ y z. (P(a,y) ∧ P(y,z)) -> P(a,z)
 ======================================== ∀E     ============ ax  ============ ax
  Γ ⊢ ∀ z. (P(a,b) ∧ P(b,z)) -> P(a,z)            Γ ⊢ P(a,b)       Γ ⊢ P(b,c)
 ====================================== ∀E       ============================= ∧I
  Γ ⊢ (P(a,b) ∧ P(b,c)) -> P(a,c)                 Γ ⊢ (P(a,b) ∧ P(b,c))
 ======================================================================= ->E
  Γ ⊢ P(a,c)



7. Let Γ :=  ¬ (∀ x. ¬ P(x)), ¬ (∃ x. P(x))

See below for continuation of ***
                                                                                                     ***
============================================= TND  ======================================== ax  ===============
 ¬ (∀ x. ¬ P(x)) ⊢ ∃ x. P(x) ∨ ¬ (∃ x. P(x))        ¬ (∀ x. ¬ P(x)), ∃ x. P(x) ⊢ ∃ x. P(x)        Γ ⊢ ∃ x. P(x)
================================================================================================================== ∨E
 ¬ (∀ x. ¬ P(x)) ⊢ ∃ x. P(x)


*** continued below:

                                       ================ ax
                                        Γ, P(t) ⊢ P(t)
         ========================= ax  ===================== ∃I
          Γ, P(t) ⊢ ¬ (∃ x. P(x))       Γ, P(t) ⊢ ∃ x. P(x)
         ========================================================= ¬E
                            Γ, P(t) ⊢ ⊥
                           ============== ¬I
                            Γ ⊢  ¬ P(t)
====================== ax  =================== ∀I
 Γ ⊢  ¬ (∀ x. ¬ P(x))       Γ ⊢  ∀ x. ¬ P(x)
====================================================== ¬E
 Γ ⊢ ⊥
=============== ⊥E
 Γ ⊢ ∃ x. P(x)
===============
   ***


* Simple recursion

> mult :: (Int, Int) -> Int
> mult (0, m) = 0
> mult (n, m) = m + mult (n-1, m)
>
> log2 :: Int -> Int
> log2 1 = 0
> log2 n = 1 + log2 (n `div` 2)
>
> isPrime :: Int -> Bool
> isPrime n = aux 2
>   where
>     aux m
>       | n `div` 2 < m    = True
>       | otherwise = n `mod` m /= 0 && aux (m+1)
